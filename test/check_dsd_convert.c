#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>
#include <gst/check/gstcheck.h>
#include "gstpwaudioformat.h"


#define NUM_CHANNELS (2)
#define NUM_PATTERN_BYTES (NUM_CHANNELS*16)


static void do_convert_check(guint8 const *src_pattern, guint8 const *expected_result, GstPipewireDsdFormat src_format, GstPipewireDsdFormat dest_format)
{
	gint i;
	guint8 convert_result[NUM_PATTERN_BYTES];

	gst_pipewire_dsd_convert(
		src_pattern, convert_result,
		src_format, dest_format,
		NUM_PATTERN_BYTES,
		NUM_CHANNELS
	);

	if (memcmp(convert_result, expected_result, NUM_PATTERN_BYTES) != 0)
	{
		GST_DEBUG("%s -> %s", gst_pipewire_dsd_format_to_string(src_format), gst_pipewire_dsd_format_to_string(dest_format));
		GST_MEMDUMP("Expected", expected_result, NUM_PATTERN_BYTES);
		GST_MEMDUMP("Actual", convert_result, NUM_PATTERN_BYTES);
	}

	for (i = 0; i < NUM_PATTERN_BYTES; ++i)
		assert_equals_int_hex(convert_result[i], expected_result[i]);
}


typedef struct
{
	GstPipewireDsdFormat format;
	guint8 bytes[NUM_PATTERN_BYTES];
}
Pattern;


static Pattern const patterns[] = {
	{
		GST_PIPEWIRE_DSD_FORMAT_DSD_U8,
		{
			0x00, 0x80, 0x01, 0x81, 0x02, 0x82, 0x03, 0x83, 0x04, 0x84, 0x05, 0x85, 0x06, 0x86, 0x07, 0x87,
			0x08, 0x88, 0x09, 0x89, 0x0A, 0x8A, 0x0B, 0x8B, 0x0C, 0x8C, 0x0D, 0x8D, 0x0E, 0x8E, 0x0F, 0x8F
		}
	},
	{
		GST_PIPEWIRE_DSD_FORMAT_DSD_U16LE,
		{
			0x01, 0x00,   0x81, 0x80,   0x03, 0x02,   0x83, 0x82,   0x05, 0x04,   0x85, 0x84,   0x07, 0x06,   0x87, 0x86,
			0x09, 0x08,   0x89, 0x88,   0x0B, 0x0A,   0x8B, 0x8A,   0x0D, 0x0C,   0x8D, 0x8C,   0x0F, 0x0E,   0x8F, 0x8E
		}
	},
	{
		GST_PIPEWIRE_DSD_FORMAT_DSD_U16BE,
		{
			0x00, 0x01,   0x80, 0x81,   0x02, 0x03,   0x82, 0x83,   0x04, 0x05,   0x84, 0x85,   0x06, 0x07,   0x86, 0x87,
			0x08, 0x09,   0x88, 0x89,   0x0A, 0x0B,   0x8A, 0x8B,   0x0C, 0x0D,   0x8C, 0x8D,   0x0E, 0x0F,   0x8E, 0x8F
		}
	},
	{
		GST_PIPEWIRE_DSD_FORMAT_DSD_U32LE,
		{
			0x03, 0x02, 0x01, 0x00,   0x83, 0x82, 0x81, 0x80,   0x07, 0x06, 0x05, 0x04,   0x87, 0x86, 0x85, 0x84,
			0x0B, 0x0A, 0x09, 0x08,   0x8B, 0x8A, 0x89, 0x88,   0x0F, 0x0E, 0x0D, 0x0C,   0x8F, 0x8E, 0x8D, 0x8C
		}
	},
	{
		GST_PIPEWIRE_DSD_FORMAT_DSD_U32BE,
		{
			0x00, 0x01, 0x02, 0x03,   0x80, 0x81, 0x82, 0x83,   0x04, 0x05, 0x06, 0x07,   0x84, 0x85, 0x86, 0x87,
			0x08, 0x09, 0x0A, 0x0B,   0x88, 0x89, 0x8A, 0x8B,   0x0C, 0x0D, 0x0E, 0x0F,   0x8C, 0x8D, 0x8E, 0x8F
		}
	}
};

static int const num_patterns = sizeof(patterns) / sizeof(Pattern);


GST_START_TEST(dsd_conversions)
{
	int i, j;

	for (i = 0; i < num_patterns; ++i)
	{
		for (j = 0; j < num_patterns; ++j)
		{
			do_convert_check(patterns[i].bytes, patterns[j].bytes, patterns[i].format, patterns[j].format);
		}
	}
}
GST_END_TEST;


static Suite * gst_stream_clock_suite(void)
{
	Suite *s = suite_create("gst_pipewire_dsd_convert");
	TCase *tc = tcase_create("general");

	suite_add_tcase(s, tc);
	tcase_add_test(tc, dsd_conversions);

	return s;
}

GST_CHECK_MAIN(gst_stream_clock);
